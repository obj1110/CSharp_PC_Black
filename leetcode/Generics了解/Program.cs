using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Generics了解
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }
}
// 泛型（使用System.Collections.Generic命名空间）是C#语言2.0和通用语言运行时（CLR）的一个新特性。泛型为.NET框架引入了类型参数（type parameters：不必确定一个或多个具体参数，属于同一类即可。这就把类型不同的隐患消灭在编译阶段——如果类型不对，则编译错误。）的概念。
//泛型的产生其中一个原因就是为了解决原来集合类中元素的装箱和拆箱问题，泛型不仅能用来做容器，还能够提供代码复用的手段。如List<T>。在泛型类型或泛型方法的定义中，类型参数是一个占位符（placeholder），通常为一个大写字母，如T。在代码声明、实例化该类型的变量时，把T替换为指定的数据类型。或者使用泛型的约束条件。

//C#的泛型采用“基类、接口、构造器，值类型/引用类型”的约束方式来实现对类型参数的“显示约束”,利用“参数化类型”将类型抽象化，能够参数化的类型越多，代码就会变得越灵活，重用性就越好。
//通过避免装箱和拆箱操作来达到性能提升的目的.如果存在约束，应对类型参数应用什么约束。一个有用的规则是，应用尽可能最多的约束，但仍使您能够处理需要处理的类型。
//例如，如果您知道您的泛型类仅用于引用类型，则应用类约束。这可以防止您的类被意外地用于值类型，并允许您对 T 使用 as 运算符以及检查空值。 是否将泛型行为分解为基类和子类。由于泛型类可以作为基类使用，此处适用的设计注意事项与非泛型类相同。有关从泛型基类继承的规则，请参见下面的内容。是否实现一个或多个泛型接口。C#的泛型类型可以应用于强大的反射技术。C#除了可以单独声明泛型类型（包括类与结构）外，也可以在基类中包含泛型类型的声明。
//但基类如果是泛型类，它的类型要么以实例化，要么来源于子类（同样是泛型类型）声明的类型参数，看如下类型
//class C<U, V>
//class D : C<string, int>
//class E<U, V> : C<U, V>
//class F<U, V> : C<string, int>
//class G : C<U, V>  //非法
//E类型为C类型提供了U、V，也就是上面说的来源于子类
//F类型继承于C<string, int>，个人认为可以看成F继承一个非泛型的类
//G类型为非法的，因为G类型不是泛型，C是泛型，G无法给C提供泛型的实例化
